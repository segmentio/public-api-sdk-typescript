/**
 * Segment Public API
 * The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.
 *
 * The version of the OpenAPI document: 61.1.2
 * Contact: friends@segment.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { DeliveryOverviewDestinationFilterBy } from '../model/deliveryOverviewDestinationFilterBy';
import { DeliveryOverviewSourceFilterBy } from '../model/deliveryOverviewSourceFilterBy';
import { DeliveryOverviewSuccessfullyReceivedFilterBy } from '../model/deliveryOverviewSuccessfullyReceivedFilterBy';
import { GetEgressFailedMetricsFromDeliveryOverview200Response } from '../model/getEgressFailedMetricsFromDeliveryOverview200Response';
import { PaginationInput } from '../model/paginationInput';
import { RequestErrorEnvelope } from '../model/requestErrorEnvelope';

import {
    ObjectSerializer,
    Authentication,
    VoidAuth,
    Interceptor,
} from '../model/models';
import {
    HttpBasicAuth,
    HttpBearerAuth,
    ApiKeyAuth,
    OAuth,
} from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.segmentapis.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DeliveryOverviewApiApiKeys {}

export class DeliveryOverviewApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        default: <Authentication>new VoidAuth(),
        token: new HttpBearerAuth(),
    };

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DeliveryOverviewApiApiKeys, value: string) {
        (this.authentications as any)[DeliveryOverviewApiApiKeys[key]].apiKey =
            value;
    }

    set accessToken(accessToken: string | (() => string)) {
        this.authentications.token.accessToken = accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Get events that failed to be delivered to Destination.
     * @summary Get Egress Failed Metrics from Delivery Overview
     * @param sourceId The sourceId for the Workspace.  This parameter exists in beta.
     * @param destinationConfigId The id tied to a Workspace Destination.  This parameter exists in beta.
     * @param startTime The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
     * @param endTime The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
     * @param granularity The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
     * @param groupBy A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and &#x60;spaceId&#x60;.  This parameter exists in beta.
     * @param filter An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and/or &#x60;spaceId&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
     * @param pagination Params to specify the page cursor and count.  This parameter exists in beta.
     */
    public async getEgressFailedMetricsFromDeliveryOverview(
        sourceId: string,
        destinationConfigId: string,
        startTime: string,
        endTime: string,
        granularity: 'DAY' | 'HOUR' | 'MINUTE',
        groupBy?: Array<string>,
        filter?: DeliveryOverviewDestinationFilterBy,
        pagination?: PaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{
        response: http.IncomingMessage;
        body: GetEgressFailedMetricsFromDeliveryOverview200Response;
    }> {
        const localVarPath =
            this.basePath + '/delivery-overview/failed-delivery';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = [
            'application/vnd.segment.v1beta+json',
            'application/json',
        ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                'Required parameter sourceId was null or undefined when calling getEgressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'destinationConfigId' is not null or undefined
        if (destinationConfigId === null || destinationConfigId === undefined) {
            throw new Error(
                'Required parameter destinationConfigId was null or undefined when calling getEgressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error(
                'Required parameter startTime was null or undefined when calling getEgressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error(
                'Required parameter endTime was null or undefined when calling getEgressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'granularity' is not null or undefined
        if (granularity === null || granularity === undefined) {
            throw new Error(
                'Required parameter granularity was null or undefined when calling getEgressFailedMetricsFromDeliveryOverview.'
            );
        }

        if (sourceId !== undefined) {
            localVarQueryParameters['sourceId'] = ObjectSerializer.serialize(
                sourceId,
                'string'
            );
        }

        if (destinationConfigId !== undefined) {
            localVarQueryParameters['destinationConfigId'] =
                ObjectSerializer.serialize(destinationConfigId, 'string');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
                startTime,
                'string'
            );
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
                endTime,
                'string'
            );
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['groupBy'] = ObjectSerializer.serialize(
                groupBy,
                'Array<string>'
            );
        }

        if (granularity !== undefined) {
            localVarQueryParameters['granularity'] = ObjectSerializer.serialize(
                granularity,
                "'DAY' | 'HOUR' | 'MINUTE'"
            );
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(
                filter,
                'DeliveryOverviewDestinationFilterBy'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'PaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: GetEgressFailedMetricsFromDeliveryOverview200Response;
            }>((resolve, reject) => {
                localVarRequest(
                    localVarRequestOptions,
                    (error, response, body) => {
                        if (error) {
                            reject(error);
                        } else {
                            if (
                                response.statusCode &&
                                response.statusCode >= 200 &&
                                response.statusCode <= 299
                            ) {
                                body = ObjectSerializer.deserialize(
                                    body,
                                    'GetEgressFailedMetricsFromDeliveryOverview200Response'
                                );
                                resolve({ response: response, body: body });
                            } else {
                                reject(
                                    new HttpError(
                                        response,
                                        body,
                                        response.statusCode
                                    )
                                );
                            }
                        }
                    }
                );
            });
        });
    }
    /**
     * Get events successfully delivered to Destination.
     * @summary Get Egress Success Metrics from Delivery Overview
     * @param sourceId The sourceId for the Workspace.  This parameter exists in beta.
     * @param destinationConfigId The id tied to a Workspace Destination.  This parameter exists in beta.
     * @param startTime The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
     * @param endTime The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
     * @param granularity The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
     * @param groupBy A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and &#x60;spaceId&#x60;.  This parameter exists in beta.
     * @param filter An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;appVersion&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, or &#x60;spaceId&#x60; that can be applied in addition to a &#x60;group By&#x60;. If you would like to view retry attempts for a successful delivery, you can filter &#x60;discard Reason&#x60; from &#x60;successes.attempt.1&#x60; through &#x60;successes.attempt.10&#x60;.  This parameter exists in beta.
     * @param pagination Params to specify the page cursor and count.  This parameter exists in beta.
     */
    public async getEgressSuccessMetricsFromDeliveryOverview(
        sourceId: string,
        destinationConfigId: string,
        startTime: string,
        endTime: string,
        granularity: 'DAY' | 'HOUR' | 'MINUTE',
        groupBy?: Array<string>,
        filter?: DeliveryOverviewDestinationFilterBy,
        pagination?: PaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{
        response: http.IncomingMessage;
        body: GetEgressFailedMetricsFromDeliveryOverview200Response;
    }> {
        const localVarPath =
            this.basePath + '/delivery-overview/successful-delivery';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = [
            'application/vnd.segment.v1beta+json',
            'application/json',
        ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                'Required parameter sourceId was null or undefined when calling getEgressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'destinationConfigId' is not null or undefined
        if (destinationConfigId === null || destinationConfigId === undefined) {
            throw new Error(
                'Required parameter destinationConfigId was null or undefined when calling getEgressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error(
                'Required parameter startTime was null or undefined when calling getEgressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error(
                'Required parameter endTime was null or undefined when calling getEgressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'granularity' is not null or undefined
        if (granularity === null || granularity === undefined) {
            throw new Error(
                'Required parameter granularity was null or undefined when calling getEgressSuccessMetricsFromDeliveryOverview.'
            );
        }

        if (sourceId !== undefined) {
            localVarQueryParameters['sourceId'] = ObjectSerializer.serialize(
                sourceId,
                'string'
            );
        }

        if (destinationConfigId !== undefined) {
            localVarQueryParameters['destinationConfigId'] =
                ObjectSerializer.serialize(destinationConfigId, 'string');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
                startTime,
                'string'
            );
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
                endTime,
                'string'
            );
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['groupBy'] = ObjectSerializer.serialize(
                groupBy,
                'Array<string>'
            );
        }

        if (granularity !== undefined) {
            localVarQueryParameters['granularity'] = ObjectSerializer.serialize(
                granularity,
                "'DAY' | 'HOUR' | 'MINUTE'"
            );
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(
                filter,
                'DeliveryOverviewDestinationFilterBy'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'PaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: GetEgressFailedMetricsFromDeliveryOverview200Response;
            }>((resolve, reject) => {
                localVarRequest(
                    localVarRequestOptions,
                    (error, response, body) => {
                        if (error) {
                            reject(error);
                        } else {
                            if (
                                response.statusCode &&
                                response.statusCode >= 200 &&
                                response.statusCode <= 299
                            ) {
                                body = ObjectSerializer.deserialize(
                                    body,
                                    'GetEgressFailedMetricsFromDeliveryOverview200Response'
                                );
                                resolve({ response: response, body: body });
                            } else {
                                reject(
                                    new HttpError(
                                        response,
                                        body,
                                        response.statusCode
                                    )
                                );
                            }
                        }
                    }
                );
            });
        });
    }
    /**
     * Get events that were filtered at Destination.
     * @summary Get Filtered At Destination Metrics from Delivery Overview
     * @param sourceId The sourceId for the Workspace.  This parameter exists in beta.
     * @param destinationConfigId The id tied to a Workspace Destination.  This parameter exists in beta.
     * @param startTime The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
     * @param endTime The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
     * @param granularity The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
     * @param groupBy A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and &#x60;spaceId&#x60;.  This parameter exists in beta.
     * @param filter An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, &#x60;app Version&#x60;, &#x60;subscription Id&#x60;, &#x60;activationId&#x60;, &#x60;audienceId&#x60;, and/or &#x60;spaceId&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
     * @param pagination Params to specify the page cursor and count.  This parameter exists in beta.
     */
    public async getFilteredAtDestinationMetricsFromDeliveryOverview(
        sourceId: string,
        destinationConfigId: string,
        startTime: string,
        endTime: string,
        granularity: 'DAY' | 'HOUR' | 'MINUTE',
        groupBy?: Array<string>,
        filter?: DeliveryOverviewDestinationFilterBy,
        pagination?: PaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{
        response: http.IncomingMessage;
        body: GetEgressFailedMetricsFromDeliveryOverview200Response;
    }> {
        const localVarPath =
            this.basePath + '/delivery-overview/filtered-at-destination';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = [
            'application/vnd.segment.v1beta+json',
            'application/json',
        ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                'Required parameter sourceId was null or undefined when calling getFilteredAtDestinationMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'destinationConfigId' is not null or undefined
        if (destinationConfigId === null || destinationConfigId === undefined) {
            throw new Error(
                'Required parameter destinationConfigId was null or undefined when calling getFilteredAtDestinationMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error(
                'Required parameter startTime was null or undefined when calling getFilteredAtDestinationMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error(
                'Required parameter endTime was null or undefined when calling getFilteredAtDestinationMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'granularity' is not null or undefined
        if (granularity === null || granularity === undefined) {
            throw new Error(
                'Required parameter granularity was null or undefined when calling getFilteredAtDestinationMetricsFromDeliveryOverview.'
            );
        }

        if (sourceId !== undefined) {
            localVarQueryParameters['sourceId'] = ObjectSerializer.serialize(
                sourceId,
                'string'
            );
        }

        if (destinationConfigId !== undefined) {
            localVarQueryParameters['destinationConfigId'] =
                ObjectSerializer.serialize(destinationConfigId, 'string');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
                startTime,
                'string'
            );
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
                endTime,
                'string'
            );
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['groupBy'] = ObjectSerializer.serialize(
                groupBy,
                'Array<string>'
            );
        }

        if (granularity !== undefined) {
            localVarQueryParameters['granularity'] = ObjectSerializer.serialize(
                granularity,
                "'DAY' | 'HOUR' | 'MINUTE'"
            );
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(
                filter,
                'DeliveryOverviewDestinationFilterBy'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'PaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: GetEgressFailedMetricsFromDeliveryOverview200Response;
            }>((resolve, reject) => {
                localVarRequest(
                    localVarRequestOptions,
                    (error, response, body) => {
                        if (error) {
                            reject(error);
                        } else {
                            if (
                                response.statusCode &&
                                response.statusCode >= 200 &&
                                response.statusCode <= 299
                            ) {
                                body = ObjectSerializer.deserialize(
                                    body,
                                    'GetEgressFailedMetricsFromDeliveryOverview200Response'
                                );
                                resolve({ response: response, body: body });
                            } else {
                                reject(
                                    new HttpError(
                                        response,
                                        body,
                                        response.statusCode
                                    )
                                );
                            }
                        }
                    }
                );
            });
        });
    }
    /**
     * Get events that were filtered at Source.
     * @summary Get Filtered At Source Metrics from Delivery Overview
     * @param sourceId The sourceId for the Workspace.  This parameter exists in beta.
     * @param startTime The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
     * @param endTime The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
     * @param granularity The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
     * @param groupBy A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and &#x60;app Version&#x60;.  This parameter exists in beta.
     * @param filter An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and/or &#x60;app Version&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
     * @param pagination Optional params to specify the page cursor and count.  This parameter exists in beta.
     */
    public async getFilteredAtSourceMetricsFromDeliveryOverview(
        sourceId: string,
        startTime: string,
        endTime: string,
        granularity: 'DAY' | 'HOUR' | 'MINUTE',
        groupBy?: Array<string>,
        filter?: DeliveryOverviewSourceFilterBy,
        pagination?: PaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{
        response: http.IncomingMessage;
        body: GetEgressFailedMetricsFromDeliveryOverview200Response;
    }> {
        const localVarPath =
            this.basePath + '/delivery-overview/filtered-at-source';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = [
            'application/vnd.segment.v1beta+json',
            'application/json',
        ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                'Required parameter sourceId was null or undefined when calling getFilteredAtSourceMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error(
                'Required parameter startTime was null or undefined when calling getFilteredAtSourceMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error(
                'Required parameter endTime was null or undefined when calling getFilteredAtSourceMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'granularity' is not null or undefined
        if (granularity === null || granularity === undefined) {
            throw new Error(
                'Required parameter granularity was null or undefined when calling getFilteredAtSourceMetricsFromDeliveryOverview.'
            );
        }

        if (sourceId !== undefined) {
            localVarQueryParameters['sourceId'] = ObjectSerializer.serialize(
                sourceId,
                'string'
            );
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
                startTime,
                'string'
            );
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
                endTime,
                'string'
            );
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['groupBy'] = ObjectSerializer.serialize(
                groupBy,
                'Array<string>'
            );
        }

        if (granularity !== undefined) {
            localVarQueryParameters['granularity'] = ObjectSerializer.serialize(
                granularity,
                "'DAY' | 'HOUR' | 'MINUTE'"
            );
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(
                filter,
                'DeliveryOverviewSourceFilterBy'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'PaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: GetEgressFailedMetricsFromDeliveryOverview200Response;
            }>((resolve, reject) => {
                localVarRequest(
                    localVarRequestOptions,
                    (error, response, body) => {
                        if (error) {
                            reject(error);
                        } else {
                            if (
                                response.statusCode &&
                                response.statusCode >= 200 &&
                                response.statusCode <= 299
                            ) {
                                body = ObjectSerializer.deserialize(
                                    body,
                                    'GetEgressFailedMetricsFromDeliveryOverview200Response'
                                );
                                resolve({ response: response, body: body });
                            } else {
                                reject(
                                    new HttpError(
                                        response,
                                        body,
                                        response.statusCode
                                    )
                                );
                            }
                        }
                    }
                );
            });
        });
    }
    /**
     * Get events that failed on ingest.
     * @summary Get Ingress Failed Metrics from Delivery Overview
     * @param sourceId The sourceId for the Workspace.  This parameter exists in beta.
     * @param startTime The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
     * @param endTime The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
     * @param granularity The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
     * @param groupBy A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and/or &#x60;appVersion&#x60;.  This parameter exists in beta.
     * @param filter An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, &#x60;discard Reason&#x60;, and/or &#x60;app Version&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
     * @param pagination Optional params to specify the page cursor and count.  This parameter exists in beta.
     */
    public async getIngressFailedMetricsFromDeliveryOverview(
        sourceId: string,
        startTime: string,
        endTime: string,
        granularity: 'DAY' | 'HOUR' | 'MINUTE',
        groupBy?: Array<string>,
        filter?: DeliveryOverviewSourceFilterBy,
        pagination?: PaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{
        response: http.IncomingMessage;
        body: GetEgressFailedMetricsFromDeliveryOverview200Response;
    }> {
        const localVarPath =
            this.basePath + '/delivery-overview/failed-on-ingest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = [
            'application/vnd.segment.v1beta+json',
            'application/json',
        ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                'Required parameter sourceId was null or undefined when calling getIngressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error(
                'Required parameter startTime was null or undefined when calling getIngressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error(
                'Required parameter endTime was null or undefined when calling getIngressFailedMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'granularity' is not null or undefined
        if (granularity === null || granularity === undefined) {
            throw new Error(
                'Required parameter granularity was null or undefined when calling getIngressFailedMetricsFromDeliveryOverview.'
            );
        }

        if (sourceId !== undefined) {
            localVarQueryParameters['sourceId'] = ObjectSerializer.serialize(
                sourceId,
                'string'
            );
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
                startTime,
                'string'
            );
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
                endTime,
                'string'
            );
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['groupBy'] = ObjectSerializer.serialize(
                groupBy,
                'Array<string>'
            );
        }

        if (granularity !== undefined) {
            localVarQueryParameters['granularity'] = ObjectSerializer.serialize(
                granularity,
                "'DAY' | 'HOUR' | 'MINUTE'"
            );
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(
                filter,
                'DeliveryOverviewSourceFilterBy'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'PaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: GetEgressFailedMetricsFromDeliveryOverview200Response;
            }>((resolve, reject) => {
                localVarRequest(
                    localVarRequestOptions,
                    (error, response, body) => {
                        if (error) {
                            reject(error);
                        } else {
                            if (
                                response.statusCode &&
                                response.statusCode >= 200 &&
                                response.statusCode <= 299
                            ) {
                                body = ObjectSerializer.deserialize(
                                    body,
                                    'GetEgressFailedMetricsFromDeliveryOverview200Response'
                                );
                                resolve({ response: response, body: body });
                            } else {
                                reject(
                                    new HttpError(
                                        response,
                                        body,
                                        response.statusCode
                                    )
                                );
                            }
                        }
                    }
                );
            });
        });
    }
    /**
     * Get events that were successfully received by Segment.
     * @summary Get Ingress Success Metrics from Delivery Overview
     * @param sourceId The sourceId for the Workspace.  This parameter exists in beta.
     * @param startTime The ISO8601 formatted timestamp corresponding to the beginning of the requested time frame, inclusive.  This parameter exists in beta.
     * @param endTime The ISO8601 formatted timestamp corresponding to the end of the requested time frame, noninclusive.  This parameter exists in beta.
     * @param granularity The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past  This parameter exists in beta.
     * @param groupBy A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: &#x60;event Name&#x60;, &#x60;event Type&#x60;, and/or &#x60;app Version&#x60;.  This parameter exists in beta.
     * @param filter An optional filter for &#x60;event Name&#x60;, &#x60;event Type&#x60;, and/or &#x60;app Version&#x60; that can be applied in addition to a &#x60;group By&#x60;.  This parameter exists in beta.
     * @param pagination Optional params to specify the page cursor and count.  This parameter exists in beta.
     */
    public async getIngressSuccessMetricsFromDeliveryOverview(
        sourceId: string,
        startTime: string,
        endTime: string,
        granularity: 'DAY' | 'HOUR' | 'MINUTE',
        groupBy?: Array<string>,
        filter?: DeliveryOverviewSuccessfullyReceivedFilterBy,
        pagination?: PaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{
        response: http.IncomingMessage;
        body: GetEgressFailedMetricsFromDeliveryOverview200Response;
    }> {
        const localVarPath =
            this.basePath + '/delivery-overview/successfully-received';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = [
            'application/vnd.segment.v1beta+json',
            'application/json',
        ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                'Required parameter sourceId was null or undefined when calling getIngressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error(
                'Required parameter startTime was null or undefined when calling getIngressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error(
                'Required parameter endTime was null or undefined when calling getIngressSuccessMetricsFromDeliveryOverview.'
            );
        }

        // verify required parameter 'granularity' is not null or undefined
        if (granularity === null || granularity === undefined) {
            throw new Error(
                'Required parameter granularity was null or undefined when calling getIngressSuccessMetricsFromDeliveryOverview.'
            );
        }

        if (sourceId !== undefined) {
            localVarQueryParameters['sourceId'] = ObjectSerializer.serialize(
                sourceId,
                'string'
            );
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(
                startTime,
                'string'
            );
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(
                endTime,
                'string'
            );
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['groupBy'] = ObjectSerializer.serialize(
                groupBy,
                'Array<string>'
            );
        }

        if (granularity !== undefined) {
            localVarQueryParameters['granularity'] = ObjectSerializer.serialize(
                granularity,
                "'DAY' | 'HOUR' | 'MINUTE'"
            );
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(
                filter,
                'DeliveryOverviewSuccessfullyReceivedFilterBy'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'PaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: GetEgressFailedMetricsFromDeliveryOverview200Response;
            }>((resolve, reject) => {
                localVarRequest(
                    localVarRequestOptions,
                    (error, response, body) => {
                        if (error) {
                            reject(error);
                        } else {
                            if (
                                response.statusCode &&
                                response.statusCode >= 200 &&
                                response.statusCode <= 299
                            ) {
                                body = ObjectSerializer.deserialize(
                                    body,
                                    'GetEgressFailedMetricsFromDeliveryOverview200Response'
                                );
                                resolve({ response: response, body: body });
                            } else {
                                reject(
                                    new HttpError(
                                        response,
                                        body,
                                        response.statusCode
                                    )
                                );
                            }
                        }
                    }
                );
            });
        });
    }
}
