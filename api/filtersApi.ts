/**
 * Segment Public API
 * The Segment Public API helps you manage your Segment Workspaces and its resources. You can use the API to perform CRUD (create, read, update, delete) operations at no extra charge. This includes working with resources such as Sources, Destinations, Warehouses, Tracking Plans, and the Segment Destinations and Sources Catalogs.  All CRUD endpoints in the API follow REST conventions and use standard HTTP methods. Different URL endpoints represent different resources in a Workspace.  See the next sections for more information on how to use the Segment Public API.
 *
 * The version of the OpenAPI document: 53.2.0
 * Contact: friends@segment.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { CreateFilterInput } from '../model/createFilterInput';
import { ListFiltersPaginationInput } from '../model/listFiltersPaginationInput';
import { RequestErrorEnvelope } from '../model/requestErrorEnvelope';
import { UpdateFilterByIdInput } from '../model/updateFilterByIdInput';

import {
    ObjectSerializer,
    Authentication,
    VoidAuth,
    Interceptor,
} from '../model/models';
import {
    HttpBasicAuth,
    HttpBearerAuth,
    ApiKeyAuth,
    OAuth,
} from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.segmentapis.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum FiltersApiApiKeys {}

export class FiltersApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        default: <Authentication>new VoidAuth(),
        token: new HttpBearerAuth(),
    };

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: FiltersApiApiKeys, value: string) {
        (this.authentications as any)[FiltersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(accessToken: string | (() => string)) {
        this.authentications.token.accessToken = accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Creates a filter.    • When called, this endpoint may generate the `Filter Created` event in the [audit trail](/tag/Audit-Trail).
     * @summary Create Filter
     * @param integrationId
     * @param CreateFilterInput
     */
    public async createFilter(
        integrationId: string,
        CreateFilterInput: CreateFilterInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath =
            this.basePath +
            '/filters/create/{integrationId}'.replace(
                '{' + 'integrationId' + '}',
                encodeURIComponent(String(integrationId))
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'integrationId' is not null or undefined
        if (integrationId === null || integrationId === undefined) {
            throw new Error(
                'Required parameter integrationId was null or undefined when calling createFilter.'
            );
        }

        // verify required parameter 'CreateFilterInput' is not null or undefined
        if (CreateFilterInput === null || CreateFilterInput === undefined) {
            throw new Error(
                'Required parameter CreateFilterInput was null or undefined when calling createFilter.'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(
                CreateFilterInput,
                'CreateFilterInput'
            ),
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any }>(
                (resolve, reject) => {
                    localVarRequest(
                        localVarRequestOptions,
                        (error, response, body) => {
                            if (error) {
                                reject(error);
                            } else {
                                if (
                                    response.statusCode &&
                                    response.statusCode >= 200 &&
                                    response.statusCode <= 299
                                ) {
                                    resolve({ response: response, body: body });
                                } else {
                                    reject(
                                        new HttpError(
                                            response,
                                            body,
                                            response.statusCode
                                        )
                                    );
                                }
                            }
                        }
                    );
                }
            );
        });
    }
    /**
     * Deletes a filter by id.    • When called, this endpoint may generate the `Filter Deleted` event in the [audit trail](/tag/Audit-Trail).
     * @summary Delete Filter By Id
     * @param id
     * @param productArea The product area of the filter  This parameter exists in alpha.
     */
    public async deleteFilterById(
        id: string,
        productArea: string,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath =
            this.basePath +
            '/filters/delete/{id}'.replace(
                '{' + 'id' + '}',
                encodeURIComponent(String(id))
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                'Required parameter id was null or undefined when calling deleteFilterById.'
            );
        }

        // verify required parameter 'productArea' is not null or undefined
        if (productArea === null || productArea === undefined) {
            throw new Error(
                'Required parameter productArea was null or undefined when calling deleteFilterById.'
            );
        }

        if (productArea !== undefined) {
            localVarQueryParameters['productArea'] = ObjectSerializer.serialize(
                productArea,
                'string'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any }>(
                (resolve, reject) => {
                    localVarRequest(
                        localVarRequestOptions,
                        (error, response, body) => {
                            if (error) {
                                reject(error);
                            } else {
                                if (
                                    response.statusCode &&
                                    response.statusCode >= 200 &&
                                    response.statusCode <= 299
                                ) {
                                    resolve({ response: response, body: body });
                                } else {
                                    reject(
                                        new HttpError(
                                            response,
                                            body,
                                            response.statusCode
                                        )
                                    );
                                }
                            }
                        }
                    );
                }
            );
        });
    }
    /**
     * Gets a filter by id.
     * @summary Get Filter By Id
     * @param id
     * @param productArea The product area of the filter, which should be spaces (endpoint table should be able to determine the resource)  This parameter exists in alpha.
     */
    public async getFilterById(
        id: string,
        productArea: string,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath =
            this.basePath +
            '/filters/filter/{id}'.replace(
                '{' + 'id' + '}',
                encodeURIComponent(String(id))
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                'Required parameter id was null or undefined when calling getFilterById.'
            );
        }

        // verify required parameter 'productArea' is not null or undefined
        if (productArea === null || productArea === undefined) {
            throw new Error(
                'Required parameter productArea was null or undefined when calling getFilterById.'
            );
        }

        if (productArea !== undefined) {
            localVarQueryParameters['productArea'] = ObjectSerializer.serialize(
                productArea,
                'string'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any }>(
                (resolve, reject) => {
                    localVarRequest(
                        localVarRequestOptions,
                        (error, response, body) => {
                            if (error) {
                                reject(error);
                            } else {
                                if (
                                    response.statusCode &&
                                    response.statusCode >= 200 &&
                                    response.statusCode <= 299
                                ) {
                                    resolve({ response: response, body: body });
                                } else {
                                    reject(
                                        new HttpError(
                                            response,
                                            body,
                                            response.statusCode
                                        )
                                    );
                                }
                            }
                        }
                    );
                }
            );
        });
    }
    /**
     * Lists filters by integration id.
     * @summary List Filters By Integration Id
     * @param integrationId
     * @param productArea The product area of the filter, which should be spaces (endpoint table should be able to determine the resource)  This parameter exists in alpha.
     * @param pagination Pagination parameters.  This parameter exists in alpha.
     */
    public async listFiltersByIntegrationId(
        integrationId: string,
        productArea: string,
        pagination?: ListFiltersPaginationInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath =
            this.basePath +
            '/filters/{integrationId}'.replace(
                '{' + 'integrationId' + '}',
                encodeURIComponent(String(integrationId))
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'integrationId' is not null or undefined
        if (integrationId === null || integrationId === undefined) {
            throw new Error(
                'Required parameter integrationId was null or undefined when calling listFiltersByIntegrationId.'
            );
        }

        // verify required parameter 'productArea' is not null or undefined
        if (productArea === null || productArea === undefined) {
            throw new Error(
                'Required parameter productArea was null or undefined when calling listFiltersByIntegrationId.'
            );
        }

        if (productArea !== undefined) {
            localVarQueryParameters['productArea'] = ObjectSerializer.serialize(
                productArea,
                'string'
            );
        }

        if (pagination !== undefined) {
            localVarQueryParameters['pagination'] = ObjectSerializer.serialize(
                pagination,
                'ListFiltersPaginationInput'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any }>(
                (resolve, reject) => {
                    localVarRequest(
                        localVarRequestOptions,
                        (error, response, body) => {
                            if (error) {
                                reject(error);
                            } else {
                                if (
                                    response.statusCode &&
                                    response.statusCode >= 200 &&
                                    response.statusCode <= 299
                                ) {
                                    resolve({ response: response, body: body });
                                } else {
                                    reject(
                                        new HttpError(
                                            response,
                                            body,
                                            response.statusCode
                                        )
                                    );
                                }
                            }
                        }
                    );
                }
            );
        });
    }
    /**
     * Updates a filter by id.    • When called, this endpoint may generate the `Filter Updated` event in the [audit trail](/tag/Audit-Trail).
     * @summary Update Filter By Id
     * @param id
     * @param UpdateFilterByIdInput
     */
    public async updateFilterById(
        id: string,
        UpdateFilterByIdInput: UpdateFilterByIdInput,
        options: { headers: { [name: string]: string } } = { headers: {} }
    ): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath =
            this.basePath +
            '/filters/update/{id}'.replace(
                '{' + 'id' + '}',
                encodeURIComponent(String(id))
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign(
            {},
            this._defaultHeaders
        );
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                'Required parameter id was null or undefined when calling updateFilterById.'
            );
        }

        // verify required parameter 'UpdateFilterByIdInput' is not null or undefined
        if (
            UpdateFilterByIdInput === null ||
            UpdateFilterByIdInput === undefined
        ) {
            throw new Error(
                'Required parameter UpdateFilterByIdInput was null or undefined when calling updateFilterById.'
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(
                UpdateFilterByIdInput,
                'UpdateFilterByIdInput'
            ),
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.token.accessToken) {
            authenticationPromise = authenticationPromise.then(() =>
                this.authentications.token.applyToRequest(
                    localVarRequestOptions
                )
            );
        }
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions)
        );

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() =>
                interceptor(localVarRequestOptions)
            );
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any }>(
                (resolve, reject) => {
                    localVarRequest(
                        localVarRequestOptions,
                        (error, response, body) => {
                            if (error) {
                                reject(error);
                            } else {
                                if (
                                    response.statusCode &&
                                    response.statusCode >= 200 &&
                                    response.statusCode <= 299
                                ) {
                                    resolve({ response: response, body: body });
                                } else {
                                    reject(
                                        new HttpError(
                                            response,
                                            body,
                                            response.statusCode
                                        )
                                    );
                                }
                            }
                        }
                    );
                }
            );
        });
    }
}
